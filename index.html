<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WebGL Application</title>
</head>
<body>
    <canvas id="glCanvas" width="800" height="600"></canvas><!-- Include the gl-matrix library from cdnjs -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gl-matrix/2.4.0/gl-matrix.js"></script>
    <script>
        // Set up the canvas
        const canvas = document.getElementById('glCanvas');

        // Initialize WebGL context
        const gl = canvas.getContext('webgl');

        // Define cube vertices
        const cubeVertices = new Float32Array([
            // Front face
            -1.0, -1.0,  1.0,
             1.0, -1.0,  1.0,
             1.0,  1.0,  1.0,
            -1.0,  1.0,  1.0,
            // Back face
            -1.0, -1.0, -1.0,
             1.0, -1.0, -1.0,
             1.0,  1.0, -1.0,
            -1.0,  1.0, -1.0,
            // Left face
            -1.0, -1.0, -1.0,
            -1.0, -1.0,  1.0,
            -1.0,  1.0,  1.0,
            -1.0,  1.0, -1.0,
            // Right face
            1.0, -1.0, -1.0,
            1.0, -1.0,  1.0,
            1.0,  1.0,  1.0,
            1.0,  1.0, -1.0,
            // Top face
            -1.0,  1.0, -1.0,
            1.0,  1.0, -1.0,
            1.0,  1.0,  1.0,
            -1.0,  1.0,  1.0,
            // Bottom face
            -1.0, -1.0, -1.0,
            1.0, -1.0, -1.0,
            1.0, -1.0,  1.0,
            -1.0, -1.0,  1.0,
        ]);

        // Define Rubik's Cube colors for each face
        const cubeColors = new Float32Array([
            // Front face (Red)
            1.0, 0.0, 0.0, 1.0,
            1.0, 0.0, 0.0, 1.0,
            1.0, 0.0, 0.0, 1.0,
            1.0, 0.0, 0.0, 1.0,
            // Front face (Red)
            1.0, 0.0, 0.0, 1.0,
            1.0, 0.0, 0.0, 1.0,
            1.0, 0.0, 0.0, 1.0,
            1.0, 0.0, 0.0, 1.0,
            // Front face (Red)
            1.0, 0.0, 0.0, 1.0,
            1.0, 0.0, 0.0, 1.0,
            1.0, 0.0, 0.0, 1.0,
            1.0, 0.0, 0.0, 1.0,
            // Front face (Red)
            1.0, 0.0, 0.0, 1.0,
            1.0, 0.0, 0.0, 1.0,
            1.0, 0.0, 0.0, 1.0,
            1.0, 0.0, 0.0, 1.0,
            // Front face (Red)
            1.0, 0.0, 0.0, 1.0,
            1.0, 0.0, 0.0, 1.0,
            1.0, 0.0, 0.0, 1.0,
            1.0, 0.0, 0.0, 1.0,
            // Front face (Red)
            1.0, 0.0, 0.0, 1.0,
            1.0, 0.0, 0.0, 1.0,
            1.0, 0.0, 0.0, 1.0,
            1.0, 0.0, 0.0, 1.0,
            /*// Back face (Green)
            0.0, 1.0, 0.0, 1.0,
            0.0, 1.0, 0.0, 1.0,
            0.0, 1.0, 0.0, 1.0,
            0.0, 1.0, 0.0, 1.0,
            // Left face (Blue)
            0.0, 0.0, 1.0, 1.0,
            0.0, 0.0, 1.0, 1.0,
            0.0, 0.0, 1.0, 1.0,
            0.0, 0.0, 1.0, 1.0,
            // Right face (Yellow)
            1.0, 1.0, 0.0, 1.0,
            1.0, 1.0, 0.0, 1.0,
            1.0, 1.0, 0.0, 1.0,
            1.0, 1.0, 0.0, 1.0,
            // Top face (White)
            1.0, 1.0, 1.0, 1.0,
            1.0, 1.0, 1.0, 1.0,
            1.0, 1.0, 1.0, 1.0,
            1.0, 1.0, 1.0, 1.0,
            // Bottom face (Orange)
            1.0, 0.5, 0.0, 1.0,
            1.0, 0.5, 0.0, 1.0,
            1.0, 0.5, 0.0, 1.0,
            1.0, 0.5, 0.0, 1.0,*/
        ]);

        // Define cube faces (using indices)
        const cubeIndices = new Uint16Array([
            0, 1, 2, 0, 2, 3,   // Front face
            4, 5, 6, 4, 6, 7,   // Back face
            8, 9, 10, 8, 10, 11,   // Left face
            12, 13, 14, 12, 14, 15,   // Right face
            16, 17, 18, 16, 18, 19,   // Top face
            20, 21, 22, 20, 22, 23    // Bottom face
        ]);

        // Define vertex shader source code
        const vertexShaderSource = `
            attribute vec4 a_position;
            attribute vec4 a_color;
            varying vec4 v_color;
            uniform mat4 u_viewprojectionMatrix;
            uniform vec2 u_d;
            uniform mat4 u_rotateZ;
            uniform float u_angle;

            void main() {
                mat4 translate = mat4(
                    1.0, 0.0, 0.0, 0.0,
                    0.0, 1.0, 0.0, 0.0,
                    0.0, 0.0, 1.0, 0.0,
                    u_d.x, 0.0, u_d.y, 1.0
                );
                float sind = sin(u_angle);
                float cosd = cos(u_angle);
                mat4 rotateX = mat4(
                    1.0, 0.0, 0.0, 0.0,
                    0.0, cosd, sind, 0.0,
                    0.0, -sind, cosd, 0.0,
                    0.0, 0.0, 0.0, 1.0
                );
                mat4 rotateY = mat4(
                    cosd, 0.0, -sind, 0.0,
                    0.0, 1.0, 0.0, 0.0,
                    sind, 0.0, cosd, 0.0,
                    0.0, 0.0, 0.0, 1.0
                );
                gl_Position = u_viewprojectionMatrix * translate * u_rotateZ * rotateY * rotateX * a_position;
                v_color = a_color;
            }
        `;

        // Define fragment shader source code
        const fragmentShaderSource = `
            precision mediump float;
            varying vec4 v_color;
            uniform vec3 uAmbientColor;

            void main() {
                // Combine ambient, diffuse, and specular lighting
                vec3 lightColor = uAmbientColor; // + diffuse + specular;
                gl_FragColor = vec4(lightColor * v_color.rgb, v_color.a);
            }
        `;

        // Compile and link shaders
        const vertexShader = gl.createShader(gl.VERTEX_SHADER);
        gl.shaderSource(vertexShader, vertexShaderSource);
        gl.compileShader(vertexShader);

        const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
        gl.shaderSource(fragmentShader, fragmentShaderSource);
        gl.compileShader(fragmentShader);

        const program = gl.createProgram();
        gl.attachShader(program, vertexShader);
        gl.attachShader(program, fragmentShader);
        gl.linkProgram(program);
        gl.useProgram(program);

        // Create buffers for cube vertices and colors
        const positionBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, cubeVertices, gl.STATIC_DRAW);

        const colorBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
        gl.bufferData(gl.ARRAY_BUFFER, cubeColors, gl.STATIC_DRAW);

        // Create a buffer for cube indices
        const indexBuffer = gl.createBuffer();
        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);
        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, cubeIndices, gl.STATIC_DRAW);

        // Specify attribute and uniform locations
        const positionAttributeLocation = gl.getAttribLocation(program, 'a_position');
        const colorAttributeLocation = gl.getAttribLocation(program, 'a_color');
        const viewProjectionMatrixLocation = gl.getUniformLocation(program, 'u_viewprojectionMatrix');

        // Set up attribute pointers
        gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
        gl.enableVertexAttribArray(positionAttributeLocation);
        gl.vertexAttribPointer(positionAttributeLocation, 3, gl.FLOAT, false, 0, 0);

        gl.bindBuffer(gl.ARRAY_BUFFER, colorBuffer);
        gl.enableVertexAttribArray(colorAttributeLocation);
        gl.vertexAttribPointer(colorAttributeLocation, 4, gl.FLOAT, false, 0, 0);

        // Set up a perspective projection matrix
        const projectionMatrix = mat4.create();
        const fieldOfView = Math.PI / 4; // 45 degrees
        const aspect = canvas.width / canvas.height;
        const zNear = 0.1;
        const zFar = 100.0;
        mat4.perspective(projectionMatrix, fieldOfView, aspect, zNear, zFar);
        
        // Set up the view matrix (camera position and orientation)
        const viewMatrix = mat4.create();
        const cameraPosition = vec3.fromValues(2.0, 2.0, 5.0); // Adjust the camera position
        const targetPosition = vec3.fromValues(0.0, 0.0, 0.0); // Point the camera at the origin
        const upVector = vec3.fromValues(0.0, 1.0, 0.0); // Define the up vector
        mat4.lookAt(viewMatrix, cameraPosition, targetPosition, upVector);

        // Combine the view matrix with the projection matrix
        const viewProjectionMatrix = mat4.create();
        mat4.multiply(viewProjectionMatrix, projectionMatrix, viewMatrix);

        // Pass the viewProjectionMatrix to your shaders as a uniform
        gl.uniformMatrix4fv(viewProjectionMatrixLocation, false, viewProjectionMatrix);

        // Rendering loop
        gl.clearColor(0.0, 0.0, 0.0, 1.0);
        gl.enable(gl.DEPTH_TEST);
        gl.viewport(0, 0, canvas.width, canvas.height);
        // Enable blending or transparency
        //gl.enable(gl.BLEND);
        // Set the blend function (commonly used for transparency)
        //gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

        // Varibles for lighting and shading
        var ambientColor = vec3.fromValues(1.0, 0.0, 1.0);
        var uAmbientColor = gl.getUniformLocation(program, "uAmbientColor");
        gl.uniform3fv(uAmbientColor, ambientColor);
        
        // Variables for animation
        let angle = 0.0;
        const angleUniformLocation = gl.getUniformLocation(program, 'u_angle');
        let rotateZMatrix = mat4.create();
        const traslationSpeed = 0.1;

        // Transformation matrix
        const rotateZUniformLocation = gl.getUniformLocation(program, 'u_rotateZ');

        // Capture the event from the keyboard
        let d = [0.0, 0.0];
        const dUniformLocation = gl.getUniformLocation(program, 'u_d');
        document.addEventListener('keydown', (event) => {
            const key = event.key;
            switch (key) {
                case 'ArrowUp':
                    d[1] -= traslationSpeed; // Move forward
                    gl.uniform2fv(dUniformLocation, d);
                    break;
                case 'ArrowDown':
                    d[1] += traslationSpeed; // Move backward
                    gl.uniform2fv(dUniformLocation, d);
                    break;
                case 'ArrowLeft':
                    d[0] -= traslationSpeed; // Move left
                    gl.uniform2fv(dUniformLocation, d);
                    break;
                case 'ArrowRight':
                    d[0] += traslationSpeed; // Move right
                    gl.uniform2fv(dUniformLocation, d);
                    break;
            }
        });

        function render() {
            angle += 0.01;
            gl.uniform1f(angleUniformLocation, angle);
            mat4.rotateZ(rotateZMatrix, rotateZMatrix, 0.01);
            gl.uniformMatrix4fv(rotateZUniformLocation, false, rotateZMatrix);

            // Clear canvas
            gl.clear(gl.COLOR_BUFFER_BIT);
            gl.drawElements(gl.TRIANGLES, cubeIndices.length, gl.UNSIGNED_SHORT, 0);

            requestAnimationFrame(render);
        }
        render();
    </script>
</body>
</html>